---
interface Props {
  "aria-hidden"?: string;
  class?: string;
  focusable?: string;
}

const { class: className } = Astro.props;
---

<div class={className}>
  <svg 
    class="w-full h-full"
    id="waterSlice"
    preserveAspectRatio="xMidYMid meet"
    viewBox="0 0 100 100"
  >
    <!-- Far edges (visible through water) -->
    <!-- Left back edge: connects from back left corner to top center point -->
    <path 
      class="text-accent-2"
      d="M 10 60 L 50 45"
      fill="none"
      opacity="0.5"
      stroke="#A5E1F3"
      stroke-width="0.5"
    />
    <!-- Right back edge: connects from back right corner to top center point -->
    <path 
      class="text-accent-2"
      d="M 90 60 L 50 45"
      fill="none"
      opacity="0.5"
      stroke="#A5E1F3"
      stroke-width="0.5"
    />
    <!-- Top face edge: connects from top center point to bottom center point -->
    <path 
      class="text-accent-2"
      d="M 50 45 L 50 35"
      fill="none"
      opacity="0.5"
      stroke="#A5E1F3"
      stroke-width="0.5"
    />
    
    <!-- Bottom far edges (lines extending to back corner) -->
    <path 
      class="text-accent-2"
      fill="none"
      id="leftBackLine"
      opacity="0.3"
      stroke="currentColor"
      stroke-width="0.5"
    />
    <path 
      class="text-accent-2"
      fill="none"
      id="rightBackLine"
      opacity="0.3"
      stroke="currentColor"
      stroke-width="0.5"
    />
    
    <!-- Paths will be updated via JavaScript -->
    <path fill="none" id="waveEdge" opacity="0.3" stroke="#A5E1F3" stroke-width="0.5" />
    <path fill="#5FB5D1" id="topFace" opacity="0.9" />
    <path fill="#4A8FA6" id="leftFace" opacity="0.8" />
    <path fill="#457F94" id="rightFace" opacity="0.8" />
  </svg>
</div>

<script>
  function generateWavePath(time: number, side: 'left' | 'right' = 'left'): string {
    const amplitude = 1;
    const frequency = 3;
    
    // Generate wave points using sine function
    const wavePoints: [number, number][] = [];
    for (let t = 0; t <= 1; t += 0.1) {
      const x = side === 'left' 
        ? 50 - (40 * t)  // Left: 50 to 10
        : 50 + (40 * t); // Right: 50 to 90
      const baseY = 65 - (15 * t); // Linear interpolation from 65 to 50
      const wave = amplitude * Math.sin(frequency * Math.PI * (t + time));
      wavePoints.push([x, baseY + wave]);
    }
    
    // Convert points to SVG path, using the first point for both M and L
    const firstPoint = wavePoints[0];
    const path = `M ${firstPoint[0]} ${firstPoint[1]} L ${firstPoint[0]} ${firstPoint[1]} `;
    return path + wavePoints
        .slice(1)
        .map((point, i) => {
            const cp = [(wavePoints[i][0] + point[0])/2, (wavePoints[i][1] + point[1])/2];
            return `Q ${cp[0]} ${cp[1]} ${point[0]} ${point[1]}`;
        })
        .join(' ');
  }

  function reverseWavePath(wavePath: string): string {
    // Step 1: Extract initial coordinates from M and L commands
    const parts = wavePath.trim().split(/\s+/);
    const startX = parts[1];
    const startY = parts[2];
    const endX = parts[4];
    const endY = parts[5];

    // Step 2: Extract Q commands into array of coordinate sets
    const qPoints = wavePath
        .trim()
        .split('Q')
        .slice(1)  // Remove the part before first Q
        .map(point => {
            const coords = point.trim().split(/\s+/).map(Number);
            return {
                controlX: coords[0],
                controlY: coords[1],
                endX: coords[2],
                endY: coords[3]
            };
        })
        .filter((point: { controlX: number | null }) => point.controlX != null); // Remove any invalid entries

    // Step 3: Reverse the points and reconstruct Q commands maintaining continuity
    const reversedCommands = [];
    for (let i = qPoints.length - 1; i >= 0; i--) {
        const currentPoint = qPoints[i];
        
        // For reversed curve, we use:
        // - The current end point as our starting point
        // - The current control point to influence the curve
        // - The previous point's end point as our new end point (or start point for the last segment)
        const nextEndPoint = i === 0 
            ? { endX: startX, endY: startY }  // Use original start point for the last segment
            : qPoints[i - 1];                 // Use previous point's end coordinates

        reversedCommands.push(
            `Q ${currentPoint.controlX} ${currentPoint.controlY} ${nextEndPoint.endX} ${nextEndPoint.endY}`
        );
    }

    // Step 4: Build the final SVG path
    const result = `M ${endX} ${endY} L ${endX} ${endY} ${reversedCommands.join(' ')} Z`;
    return result;
}

// 10 Q points each with four values
// M 50 65 L 50 64.25405885457582 Q 52 63.37955391879726 54 62.5050489830187 Q 56 61.82056278291293 58 61.13607658280716 Q 60 60.61658507354675 62 60.09709356428634 Q 64 59.6545503371042 66 59.212007109922055 Q 68 58.72897412767312 70 58.24594114542418 Q 72 57.62044608120274 74 56.9949510169813 Q 76 56.17943721708707 78 55.36392341719284 Q 80 54.383414926453256 82 53.40290643571367 Q 84 52.3454496628958 86 51.287992890077945 Q 88 50.27102587232688 90 49.25405885457582

// left wave path goes from 50,65 to 10,50
// right wave path goes from 50,65 to 90,50
// we want to reverse the right wave path and then combine the two to make the top face

  function updatePaths(time: number): void {
    const leftWavePath = generateWavePath(time, 'left');
    const rightWavePath = generateWavePath(time, 'right');
    
    // Get the end coordinates from both waves
    const leftWaveCoords = leftWavePath.split(' ').slice(-2);
    const rightWaveCoords = rightWavePath.split(' ').slice(-2);
    const [leftEndX, leftEndY] = leftWaveCoords;
    const [rightEndX, rightEndY] = rightWaveCoords;

    // Update the back lines to connect to the wave endpoints
    const leftBackLine = document.getElementById('leftBackLine');
    if (leftBackLine) {
      leftBackLine.setAttribute('d', `M 10 60 L ${leftEndX} ${leftEndY}`);
    }

    const rightBackLine = document.getElementById('rightBackLine');
    if (rightBackLine) {
      rightBackLine.setAttribute('d', `M 90 60 L ${rightEndX} ${rightEndY}`);
    }

    // Update the wave edge (using left wave)
    const waveEdge = document.getElementById('waveEdge');
    if (waveEdge) {
      waveEdge.setAttribute('d', leftWavePath);
    }
    
    // Get the start coordinates from both waves
    const leftStartCoords = leftWavePath.split(' ').slice(1, 3);
    const rightStartCoords = rightWavePath.split(' ').slice(1, 3);

    // Generate reversed right wave and remove the " Z" at the end of the path
    const reversedRightWave = reverseWavePath(rightWavePath);
    const cleanReversedRightWave = reversedRightWave.replace(/^M [0-9.-]+ [0-9.-]+ L [0-9.-]+ [0-9.-]+ /, '').slice(0, -2);
  
    // Update top face
    const topPath = `M ${leftEndX} ${leftEndY} L 50 35 L ${rightEndX} ${rightEndY} ${cleanReversedRightWave} ${leftWavePath.substring(leftWavePath.indexOf('Q'))} Z`;
    const topFace = document.getElementById('topFace');
    if (topFace) {
      topFace.setAttribute('d', topPath);
    }
    
    // Update left face
    const leftPath = `M 10 50 L 10 60 L 50 75 L ${leftStartCoords[0]} ${leftStartCoords[1]} ${leftWavePath.substring(leftWavePath.indexOf('Q'))} Z`;
    const leftFace = document.getElementById('leftFace');
    if (leftFace) {
      leftFace.setAttribute('d', leftPath);
    }

    // Update right face
    const rightPath = `M 90 50 L 90 60 L 50 75 L ${rightStartCoords[0]} ${rightStartCoords[1]} ${rightWavePath.substring(rightWavePath.indexOf('Q'))} Z`;
    const rightFace = document.getElementById('rightFace');
    if (rightFace) {
      rightFace.setAttribute('d', rightPath);
    }
  }

  // Animation loop
  let startTime = Date.now();
  function animate() {
    const time = (Date.now() - startTime) / 2000;
    updatePaths(time);
    requestAnimationFrame(animate);
  }

  animate();
</script>